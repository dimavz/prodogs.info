(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
(function (global){
'use strict';

var _store = require('./store');

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Initialize `joms` object if not found.
window.joms = window.joms || {};

window.joms.store = _store2.default;

(function (global, factory) {

    if (!joms.getData('is_chat_view')) {
        joms_observer.add_action('chat_initialized', factory, 1, 1);
    }
})(window, function () {
    var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
        Chatbar = require('./components/chatbar'),
        store = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).store,
        app = void 0;

    app = new Vue({
        store: store,
        render: function render(createElement) {
            return createElement(Chatbar);
        },
        mounted: function mounted() {
            var store = this.$store;

            store.dispatch('chats/fetch', joms.chat).then(function () {

                _.each(joms.chat.conversations, function (item) {
                    store.dispatch('chats/addSidebarItem', item.id);
                });

                store.dispatch('chats/syncState');
            });
        }
    }).$mount();

    // Append element to the document root.
    document.body.appendChild(app.$el);

    jQuery('body').on('click', function (e) {
        var el = jQuery(e.target).parents('.joms-chatbar');
        if (!el.length) {
            joms.store.dispatch('chats/setActiveWindow', 0);
        }
    });
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./components/chatbar":6,"./store":17}],2:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    localStore = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage,
    settings = window.joms_plg_jomsocialchatbar || {},
    configs = settings.configs || {},
    templates = settings.templates || {};

module.exports = Vue.component('chatbar-sidebar', {
    template: templates.chatbar_sidebar,
    data: function data() {
        var data, state;

        data = {
            expanded: true,
            fetching: false,
            fetchDone: false
        };

        if (+configs.remember_last_state) {
            state = localStore.get('chatbar') || {};
            _.extend(data, state.sidebar || {});
        }

        return data;
    },
    computed: {
        chats: function chats() {
            return this.$store.getters['chats/sidebar'];
        }
    },
    methods: {
        open: function open(id) {
            this.$store.dispatch('chats/open', id);
        },
        toggle: function toggle() {
            var config = localStore.get('chatbar') || {},
                configSidebar = config.sidebar || {};

            this.expanded = !this.expanded;
            _.extend(configSidebar, { expanded: this.expanded });
            _.extend(config, { sidebar: configSidebar });

            localStore.set('chatbar', config);
        },
        fetch: function fetch(ids) {
            if (!this.fetching && !this.fetchDone) {
                this.fetching = true;
                this.fetchDebounced(ids);
            }
        },
        fetchDebounced: function fetchDebounced(ids) {
            var that = this;
            this.$store.dispatch('chats/fetchMore', { list: ids }).fail(function () {
                that.fetchDone = true;
            }).always(function () {
                that.fetching = false;
            });
        },
        handleScroll: function handleScroll(e) {
            var el = e.currentTarget,
                scrollTop = el.scrollTop,
                delta = e.deltaY,
                height;
            if (scrollTop === 0 && delta < 0) {
                e.preventDefault();
                e.stopPropagation();
            } else {
                var items = el.querySelectorAll('.joms-chat__item');
                var ids = [];
                for (var i = 0; i < items.length; i++) {
                    ids.push(+items[i].getAttribute('data-id'));
                }
                height = el.scrollHeight - el.clientHeight;
                if (Math.abs(scrollTop - height) <= 1 && delta > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!this.fetchDone) {
                        this.fetch(ids);
                    }
                }
            }
        },
        setActiveWindow: function setActiveWindow(chat) {
            this.$store.dispatch('chats/setActiveWindow', +chat.id);
            this.$store.dispatch('chats/open', +chat.id);
            if (+chat.seen === 0) {
                this.$store.dispatch('chats/seen', +chat.id);
            }
        }
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
'use strict';

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),
    joms = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null),
    Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    user_id = String(window.joms_my_id || ''),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {};

module.exports = Vue.component('chatbar-window-input', {
    template: templates.chatbar_window_input,
    props: ['chat', 'active'],
    data: function data() {
        return {
            attachment: false
        };
    },
    mounted: function mounted() {
        if (this.active) {
            this.focus();
        }
    },
    watch: {
        active: function active(val) {
            if (val) {
                this.focus();
            }
        }
    },
    methods: {
        focus: function focus() {
            this.$el.querySelector('input').focus();
        },
        submit: function submit(event) {
            var input = event.target,
                timestamp = new Date().getTime(),
                attachment = JSON.parse(JSON.stringify(this.attachment || {})),
                data;
            if (!input.value.trim()) {
                return;
            }
            data = {
                chat_id: this.chat.id,
                user_id: user_id,
                action: 'sent',
                content: input.value,
                attachment: attachment,
                params: { attachment: attachment },
                created_at: Math.floor(timestamp / 1000)
            };

            input.value = '';
            this.attachment = false;
            this.$emit('submit', data);
        },
        attachImage: function attachImage(e) {
            var that = this,
                baseUrl = joms.getData('base_url'),
                url = baseUrl + 'index.php?option=com_community&view=photos&task=ajaxPreviewComment',
                extensions = 'jpg,jpeg,png,gif';

            doUpload({
                url: url,
                filters: { mime_types: [{ title: 'Image files', extensions: extensions }] },
                max_file_size: undefined
            }).done(function (file, json) {
                that.attachment = {
                    type: 'image',
                    id: json.photo_id,
                    url: json.thumb_url
                };
            });
        },
        attachFile: function attachFile(e) {
            var that = this,
                baseUrl = joms.getData('base_url'),
                url = baseUrl + 'index.php?option=com_community&view=files&task=multiUpload&type=chat&id' + this.chat.id,
                extensions = 'bmp,csv,doc,gif,ico,jpg,jpeg,odg,odp,ods,odt,pdf,png,ppt,swf,txt,xcf,xls,BMP,CSV,DOC,GIF,ICO,JPG,JPEG,ODG,ODP,ODS,ODT,PDF,PNG,PPT,SWF,TXT,XCF,XLS';

            doUpload({
                url: url,
                filters: { mime_types: [{ title: 'Document files', extensions: extensions }] },
                max_file_size: undefined
            }).done(function (file, json) {
                that.attachment = {
                    type: 'file',
                    id: json.id,
                    url: json.path,
                    name: file.name
                };
            });
        },
        removeAttachment: function removeAttachment(e) {
            this.attachment = false;
        }
    }
});

////////////////////////////////////////////////////////////////////////////////////////////////////
// FILE UPLOADER
////////////////////////////////////////////////////////////////////////////////////////////////////

var _uploader, _uploaderButton, _uploaderDefer;

function doUpload(settings) {
    return $.Deferred(function (defer) {
        initUpload(defer).done(function (uploader, $button) {
            uploader.refresh();
            uploader.settings.url = settings.url;
            uploader.settings.filters = settings.filters;
            uploader.settings.max_file_size = settings.max_file_size;
            uploader.refresh();
            $button.click();
        });
    });
}

function initUpload(defer) {
    // Save defer object for later use.
    _uploaderDefer = defer;

    return $.Deferred(function (defer) {
        if (_uploader) {
            defer.resolve(_uploader, _uploaderButton);
            return;
        }

        joms.util.loadLib('plupload', function () {
            setTimeout(function () {
                var id = 'joms-js--jomsocialchatbar-uploader',
                    url = joms.getData('base_url') + 'index.php?option=com_community',
                    $container,
                    $button;

                $container = $('<div id="' + id + '" aria-hidden="true" />').css({ width: 1, height: 1, overflow: 'hidden' }).appendTo(document.body);

                $button = $('<button id="' + id + '-button" />').appendTo($container);

                _uploader = new window.plupload.Uploader({
                    url: url,
                    container: id,
                    browse_button: id + '-button',
                    runtimes: 'html5,html4',
                    multi_selection: false
                });

                _uploader.bind('FilesAdded', function (up) {
                    setTimeout(function () {
                        up.start();
                        up.refresh();
                    }, 1);
                });

                _uploader.bind('Error', function (up, error) {
                    window.alert(error && error.message || 'Undefined error.');
                });

                _uploader.bind('FileUploaded', function (up, file, info) {
                    var json, ct, loading, thumb, button, img, label;

                    try {
                        json = JSON.parse(info.response);
                    } catch (e) {}

                    json = json || {};

                    if (json.error || json.msg) {
                        window.alert(json.error || json.msg);
                        _uploaderDefer.reject();
                        return;
                    }

                    if (!(json.thumb_url && json.photo_id || json.id)) {
                        window.alert('Undefined error.');
                        _uploaderDefer.reject();
                        return;
                    }

                    _uploaderDefer.resolve(file, json);
                });

                _uploader.init();

                _uploaderButton = $container.find('input[type=file]');
                defer.resolve(_uploader, _uploaderButton);
            });
        });
    });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    USER_ID = +(window.joms_my_id || ''),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {};

module.exports = Vue.component('chatbar-window-search', {
    template: templates.chatbar_window_search,
    props: ['participants'],
    data: function data() {
        return {
            inputWidth: 10,
            queryResults: [],
            selectedIds: [],
            selectedNames: []
        };
    },
    computed: {
        selectedUsers: function selectedUsers() {
            return _.map(this.selectedIds, function (id, index) {
                return { id: id, name: this.selectedNames[index] };
            }, this);
        }
    },
    mounted: function mounted() {
        this.$input = this.$el.querySelector('.joms-js-input');
    },
    methods: {

        /**
         * Reset selected users.
         */
        reset: function reset() {
            this.selectedIds = [];
            this.selectedNames = [];
        },

        /**
         * Submit selected users.
         */
        add: function add() {
            var selected = JSON.parse(JSON.stringify(this.selectedIds));
            this.$emit('done', selected);
            _.each(selected, function (id) {
                this.participants.push(id);
            }, this);

            this.reset();
        },

        /**
         * Cancel select users.
         */
        cancel: function cancel() {
            this.reset();
            this.$emit('hide');
        },

        /**
         * Search users by keyword.
         * @param {string} keyword
         */
        search: function search(keyword) {
            var users = this.$store.getters['users/search'](keyword),
                filtered = this.filterSelected(users);

            this.queryResults = filtered;
        },

        /**
         * Select user.
         */
        select: function select(id) {
            var name;

            if (this.selectedIds.indexOf(id) === -1) {
                name = this.$store.getters['users/name'](id);
                this.selectedIds.push(id);
                this.selectedNames.push(name);
                this.queryResults = [];
                this.$input.value = '';
                this.$input.focus();
            }
        },

        /**
         * Remove selected user.
         */
        removeSelected: function removeSelected(id) {
            var index = this.selectedIds.indexOf(+id);

            if (index !== -1) {
                this.selectedIds.splice(index, 1);
                this.selectedNames.splice(index, 1);
                this.queryResults = this.filterSelected(this.queryResults);
            }
        },

        /**
         * Filter-out selected users for the list.
         * @param {Object[]} users
         */
        filterSelected: function filterSelected(users) {
            var participants = this.participants,
                selected = this.selectedIds;

            return _.filter(users, function (user) {
                var id = +user.id,
                    allow = true;

                if (id === USER_ID) {
                    allow = false;
                } else if (participants.indexOf(id) > -1) {
                    allow = false;
                } else if (selected.indexOf(id) > -1) {
                    allow = false;
                }

                return allow;
            });
        },

        /**
         * Handle click on fake input.
         */
        onInputClick: function onInputClick(e) {
            this.$el.querySelector('.joms-js-input').focus();
        },

        /**
         * Handle search users by keyword.
         */
        onInputKeyup: _.throttle(function (e) {
            if (!this.shadowInput) {
                this.shadowInput = this.$el.querySelector('.joms-input--shadow');
            }

            this.shadowInput.innerHTML = e.target.value;
            this.inputWidth = this.shadowInput.clientWidth + 20;
            this.search(e.target.value.trim());
        }, 50),

        /**
         * Handle select user.
         * @param {number} id
         */
        onSelect: function onSelect(id) {
            this.select(+id);
        }

    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (global){
'use strict';

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),
    Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    ChatbarWindowSearch = require('./chatbar-window-search'),
    ChatbarWindowInput = require('./chatbar-window-input'),
    user_id = String(window.joms_my_id || ''),
    settings = window.joms_plg_jomsocialchatbar || {},
    templates = settings.templates || {},
    moment = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).moment;;

module.exports = Vue.component('chatbar-window', {
    template: templates.chatbar_window,

    components: {
        ChatbarWindowSearch: ChatbarWindowSearch,
        ChatbarWindowInput: ChatbarWindowInput
    },

    props: ['chat'],

    data: function data() {
        var participants = JSON.parse(JSON.stringify(this.chat.users));
        return {
            setting: false,
            adding: false,
            loading: false,
            myId: user_id,
            participants: participants,
            scrollTop: 0,
            currentHeight: 0,
            initData: false,
            fetchDone: false,
            scrollPosition: 'bottom'
        };
    },

    mounted: function mounted() {
        this.initializeData();
    },

    computed: {
        active: function active() {
            return this.$store.state.chats.active == this.chat.id;
        },

        chatName: function chatName() {
            var names = [],
                users = this.$store.state.users;

            this.chat.users.forEach(function (id) {
                if (users[id]) {
                    names.push(users[id].name);
                }
            });

            return this.formatName(names);
        },

        dgroups: function dgroups() {
            var chats = this.$store.state.chats.info,
                chatid = this.chat.id,
                messagesX = void 0,
                grouped = [],
                dateIndexPrev = void 0,
                userIndexPrev = void 0;

            if (chats[this.chat.id]) {
                messagesX = this.$store.state.chats.messages.filter(function (item) {
                    return +item.chat_id === +chatid;
                });

                for (var i = 0; i < messagesX.length; i++) {
                    var message = messagesX[i],
                        date = new Date(message.created_at * 1000),
                        dateIndex = date.toJSON().slice(0, 10).replace(/-/g, ''),
                        userIndex = String(message.user_id),
                        dateFormatted = this.formatDate(date.getTime()),
                        timeFormatted = this.formatTime(date.getTime()),
                        messages = void 0;

                    if (message.action === 'seen') {
                        continue;
                    }

                    if (dateIndex !== dateIndexPrev) {
                        dateIndexPrev = dateIndex;
                        userIndexPrev = undefined;

                        grouped.push({
                            date: dateIndex,
                            dateFormatted: dateFormatted,
                            messages: []
                        });
                    }

                    messages = grouped[grouped.length - 1].messages;
                    if (message.action !== 'sent') {
                        userIndexPrev = undefined;
                        messages.push({
                            info: message.action,
                            messages: []
                        });
                    } else if (userIndex !== userIndexPrev) {
                        userIndexPrev = userIndex;
                        messages.push({
                            user: userIndex,
                            messages: []
                        });
                    }

                    messages = messages[messages.length - 1].messages;
                    messages.push(_.extend({}, message, {
                        timeFormatted: timeFormatted
                    }));
                }
            }

            return grouped;
        },

        oldestMsg: function oldestMsg() {
            var self = this,
                messages = this.$store.state.chats.messages,
                ids = void 0,
                chatMsg = void 0,
                oldest = void 0;

            chatMsg = messages.filter(function (item) {
                return +item.id && +item.chat_id === +self.chat.id;
            });

            ids = chatMsg.map(function (item) {
                return +item.id;
            });

            if (ids.length) {
                oldest = ids.reduce(function (a, b) {
                    return Math.min(a, b);
                });
                return oldest;
            } else {
                return 0;
            }
        },

        seenBy: function seenBy() {
            var self = this;

            if (self.chat.seenBy && +joms.getData('chat_enablereadstatus')) {
                var users = self.$store.state.users;

                return self.chat.seenBy.filter(function (id) {
                    return users[id] && +id != +self.myId;
                }).map(function (id) {
                    return users[id].name;
                });
            } else {
                return [];
            }
        },

        seenUsers: function seenUsers() {
            if (this.seenBy.length) {
                return this.seenBy.join('<br>');
            } else {
                return '';
            }
        },

        seenText: function seenText() {
            return Joomla.JText._('PLG_JOMSOCIALCHATBAR_SEEN');
        }
    },

    beforeUpdate: function beforeUpdate() {
        this.scrollHeightBeforeUpdate = this.$el.querySelector('.joms-js-scrollable').scrollHeight;
    },

    updated: function updated() {
        var container = this.$el.querySelector('.joms-js-scrollable'),
            scrollHeight = void 0;

        if (!this.active) {
            this.setting = false;
        }

        if (this.initData) {
            container.scrollTop = container.scrollHeight;
            this.initData = false;
            return;
        }

        if (this.scrollHeightBeforeUpdate != container.scrollHeight && this.scrollPosition === 'top') {
            scrollHeight = Math.abs(container.scrollHeight - this.scrollHeightBeforeUpdate);
            container.scrollTop = scrollHeight;
            this.scrollPosition = 'middle';
            return;
        }

        if (this.scrollPosition === 'bottom') {
            container.scrollTop = container.scrollHeight;
            return;
        }
    },

    methods: {
        add: function add() {
            this.setting = false;
            this.adding = true;
        },

        leave: function leave() {
            this.setting = false;
            if (confirm(Joomla.JText._('PLG_JOMSOCIALCHATBAR_ARE_YOU_SURE_TO_LEAVE_THIS_CONVERSATION'))) {
                this.$store.dispatch('chats/leave', this.chat.id);
            }
        },

        toggle: function toggle() {
            this.$store.dispatch('chats/toggle', this.chat.id);
            this.setActive(this.chat);
        },

        toggleSetting: function toggleSetting(status) {
            if (status === 'hide') {
                this.setting = false;
            } else {
                this.setting = !this.setting;
            }
        },

        close: function close() {
            this.$store.dispatch('chats/close', this.chat.id);
        },

        initializeData: function initializeData(direction) {
            var self = this,
                chatid = self.chat.id,
                payload = { id: this.chat.id, oldestMsg: this.oldestMsg };

            if (self.chat.initialized) {
                self.initData = true;
                return;
            }

            self.loading = true;

            self.$store.dispatch('chats/messages/fetch', payload).then(function (data) {
                self.loading = false;
                self.initData = true;
                self.$store.dispatch('chats/initialized', { id: +chatid });
                if (data.seen.length) {
                    data.seen.forEach(function (item) {
                        self.$store.dispatch('chats/seenBy', { chatid: +item.chat_id, userid: +item.user_id });
                    });
                }
            });
        },

        loadOlderMessages: function loadOlderMessages() {
            var self = this,
                chatid = self.chat.id,
                store = self.$store,
                payload = { id: self.chat.id, oldestMsg: self.oldestMsg };

            if (self.loading) {
                return;
            }

            self.loading = true;

            store.dispatch('chats/messages/fetch', payload).then(function (data) {
                self.loading = false;
                if (data.messages.length === 0) {
                    self.fetchDone = true;
                }
            });
        },

        handleScroll: function handleScroll(e) {
            var container = this.$el.querySelector('.joms-js-scrollable');

            if (!container.scrollTop) {
                this.scrollPosition = 'top';
            } else if (container.scrollTop === container.scrollHeight - container.clientHeight) {
                this.scrollPosition = 'bottom';
            } else {
                this.scrollPosition = 'middle';
            }

            if (this.scrollPosition === 'bottom' && this.active && !this.chat.seen) {
                this.$store.dispatch('chats/seen', +this.chat.id);
            }
        },

        handleWheel: function handleWheel(e) {
            var el = e.currentTarget,
                scrollTop = el.scrollTop,
                delta = e.deltaY,
                height = void 0;

            if (scrollTop === 0 && delta < 0) {
                e.preventDefault();

                if (this.fetchDone) {
                    return false;
                }

                this.loadOlderMessages();
            } else {
                height = el.scrollHeight - el.clientHeight;
                if (Math.abs(scrollTop - height) <= 1 && delta > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        },

        replaceLink: function replaceLink(value) {
            return value.replace(/((http|https):\/\/.*?[^\s]+)/g, '<a target="_blank" style="text-decoration:underline" href="$1">$1</a>');
        },

        replaceNewline: function replaceNewline(value) {
            return value.replace(/\\n/g, '<br />').replace(/\r?\n/g, '<br />');
        },

        getName: function getName(id) {
            return this.$store.getters['users/name'](id);
        },

        replaceEmoticon: function replaceEmoticon(value) {
            var emoticons = {
                happy2: /(:happy:|:\)\))/g, // [ ':happy:', ':))' ]
                smiley2: /(:smile:|:\)|:-\))/g, // [ ':smile:', ':)', ':-)' ]
                tongue2: /(:tongue:|:p|:P)/g, // [ ':tongue:', ':p', ':P' ]
                wink2: /(:wink:|;\))/g, // [ ':wink:', ';)' ]
                cool2: /(:cool:|B\))/g, // [ ':cool:', 'B)' ]
                angry2: /(:angry:|>:\(|&gt;:\()/g, // [ ':angry:', '>:(', '&gt;:(' ]
                sad2: /(:sad:|:\()/g, // [ ':sad:', ':(' ]
                evil2: /(:evil:|>:D|&gt;:D)/g, // [ ':evil:', '>:D', '&gt;:D' ]
                grin2: /(:grin:|:D)/g, // [ ':grin:', ':D' ]
                shocked2: /(:shocked:|:o|:O)/g, // [ ':shocked:', ':o', ':O' ]
                confused2: /(:confused:|:\?)/g, // [ ':confused:', ':?' ]
                neutral2: /(:neutral:|:\|)/g, // [ ':neutral:', ':|' ]
                heart: /(:love:|<3|&lt;3)/g // [ ':love:', '<3', '&lt;3' ]
            };

            _.each(emoticons, function (regex, key) {
                var replace = '<i class="joms-status-emoticon joms-icon-' + key + '"></i>';
                value = value.replace(regex, replace);
            });

            return value;
        },

        photoZoom: function photoZoom(url) {
            joms.api.photoZoom(url);
        },

        addUsers: function addUsers(userIds) {
            var payload = void 0;

            this.adding = false;
            if (userIds && userIds.length) {
                payload = { chatid: this.chat.id, userids: userIds };
                this.$store.dispatch('chats/addUsers', payload);
            }
        },

        submit: function submit(data) {
            var store = this.$store,
                chatid = this.chat.id;

            this.scrollPosition = 'bottom';

            store.dispatch('chats/messages/submit', {
                id: chatid,
                data: data
            }).then(function () {
                store.dispatch('chats/setTopSidebar', chatid);
            });

            store.dispatch('chats/clearSeen', { chatid: chatid });
        },

        mute: function mute(state) {
            var action = state ? 'chats/mute' : 'chats/unmute';
            this.$store.dispatch(action, { id: this.chat.id });
        },

        showTooltip: function showTooltip(e) {
            var el = $(e.currentTarget),
                tooltip = el.attr('data-tooltip'),
                position = el.offset();

            if (!this.$tooltip) {
                this.$tooltip = $('<div class="joms-tooltip joms-js-chat-tooltip" />').appendTo(document.body);
            }

            this.$tooltip.html(tooltip).show();

            if (el.hasClass('joms-chat__messages-seen_status')) {
                this.$tooltip.addClass('joms_chat__seen-tooltip').css({
                    left: position.left,
                    top: position.top - 5,
                    transform: 'translateY(-100%)'
                });
            } else {
                this.$tooltip.removeClass('joms_chat__seen-tooltip').css({
                    left: position.left - this.$tooltip.outerWidth() - 10,
                    top: position.top + el.outerHeight() / 2,
                    transform: 'translateY(-50%)'
                });
            }
        },

        hideTooltip: function hideTooltip(e) {
            if (this.$tooltip) {
                this.$tooltip.hide();
            }
        },

        setActive: function setActive(chat) {
            this.$store.dispatch('chats/setActiveWindow', +chat.id);
            if (+chat.seen === 0 && this.scrollPosition === 'bottom') {
                this.$store.dispatch('chats/seen', +chat.id);
            }
        },

        formatDate: function formatDate(timestamp) {
            var now = moment(),
                date = moment(timestamp),
                format = 'D MMM';

            if (now.year() !== date.year()) {
                format = 'D/MMM/YY';
            }

            return date.format(format);
        },
        formatTime: function formatTime(timestamp) {
            var time = moment(timestamp),
                format = joms.getData('chat_time_format') || 'g:i A';

            // PHP-to-Moment time format conversion.
            format = format.replace(/[GH]/g, 'H').replace(/[gh]/g, 'h').replace(/i/ig, 'mm').replace(/s/ig, 'ss');

            return this.formatDate(timestamp) + ' ' + time.format(format);
        },


        formatName: function formatName(names) {
            if (!_.isArray(names)) {
                names = [names];
            }

            if (names.length === 1) {
                names = names[0];
            } else if (names.length > 1) {
                names = _.map(names, function (str, span) {
                    // Remove badge on group conversations.
                    if (str.indexOf('<') >= 0) {
                        span = document.createElement('span');
                        span.innerHTML = str;
                        str = span.innerText;
                    }

                    str = str.split(' ');
                    return str[0];
                });
                names = names.sort();
                names = names.join(', ');
                names = names.replace(/,\s([^\s]*)$/, ' and $1');
            } else {
                names = '';
            }

            return names;
        }

    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chatbar-window-input":3,"./chatbar-window-search":4}],6:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    ChatbarSidebar = require('./chatbar-sidebar'),
    ChatbarWindow = require('./chatbar-window'),
    settings = window.joms_plg_jomsocialchatbar || {},
    configs = settings.configs || {},
    templates = settings.templates || {};

module.exports = Vue.component('chatbar', {
    template: templates.chatbar,
    components: {
        ChatbarSidebar: ChatbarSidebar,
        ChatbarWindow: ChatbarWindow
    },
    data: function data() {
        var data = {
            position: 'right',
            limitOpened: 0
        };

        if (configs.chat_bar_position) {
            data.position = configs.chat_bar_position;
        }

        return data;
    },
    mounted: function mounted() {
        this.setLimitOpened();
        window.addEventListener('resize', this.setLimitOpened);
    },
    computed: {
        openedChats: function openedChats() {
            var store = this.$store,
                messages = store.getters['chats/messages/groupedMessages'],
                getter = store.getters['chats/opened'],
                opened = getter.opened,
                needClose = getter.needClose;

            _.each(needClose, function (id) {
                store.dispatch('chats/close', id);
            });

            return opened;
        }
    },

    methods: {
        setLimitOpened: function setLimitOpened() {
            this.$store.dispatch('chats/setLimitOpened');
        }
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chatbar-sidebar":2,"./chatbar-window":5}],7:[function(require,module,exports){
'use strict';

function formatName(names) {
    if (!_.isArray(names)) {
        names = [names];
    }

    if (names.length === 1) {
        names = names[0];
    } else if (names.length > 1) {
        names = _.map(names, function (str, span) {
            // Remove badge on group conversations.
            if (str.indexOf('<') >= 0) {
                span = document.createElement('span');
                span.innerHTML = str;
                str = span.innerText;
            }

            str = str.split(' ');
            return str[0];
        });
        names = names.sort();
        names = names.join(', ');
        names = names.replace(/,\s([^\s]*)$/, ' and $1');
    } else {
        names = '';
    }

    return names;
}

module.exports = {

    /**
     * Fetch conversation list.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     */
    fetch: function fetch(context, payload) {
        return jQuery.Deferred(function (defer) {
            _.each(payload.buddies, function (item) {
                context.commit('users/add', { data: item }, { root: true });
            });

            _.each(payload.conversations, function (item) {
                item.id = String(item.chat_id);
                item.name = formatName(item.name);
                delete item.chat_id;
                context.commit('add', item);
            });

            _.each(payload.opened, function (item) {
                item.id = String(item.chat_id);
                item.name = formatName(item.name);
                delete item.chat_id;

                context.commit('add', item);
            });

            defer.resolve();
        });
    },

    fetchMore: function fetchMore(context, payload) {
        return jQuery.Deferred(function (defer) {
            joms.ajax({
                func: 'chat,ajaxInitializeChatData',
                data: [JSON.stringify(payload.list)],
                callback: function callback(json) {
                    var empty = true;
                    _.each(json.buddies, function (item) {
                        context.commit('users/add', { data: item }, { root: true });
                    });

                    _.each(json.list, function (item) {
                        item.id = String(item.chat_id);
                        item.name = formatName(item.name);
                        delete item.chat_id;

                        context.commit('add', item);
                        context.commit('addSidebarItem', item.id);
                        empty = false;
                    });

                    if (empty) {
                        defer.reject();
                    } else {
                        defer.resolve();
                    }
                }
            });
        });
    },

    initialized: function initialized(context, payload) {
        context.commit('initialized', payload);
    },

    /**
     * Check updates on conversation state.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @return {jQuery.Deferred}
     */
    check: function check(context) {
        var opened = _.map(context.getters['opened'], function (item) {
            return item.id;
        });

        return context.dispatch('messages/check', { ids: opened });
    },

    /**
     * Open a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    open: function open(context, id) {
        var chat = context.state.info[id];
        if (chat) {
            context.commit('open', id);
            context.commit('storeState');
        }
    },

    /**
     * Close a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    close: function close(context, id) {
        var chat = context.state.info[id];
        if (chat && chat.open) {
            context.commit('close', id);
            context.commit('storeState');
        }
    },

    /**
     * Toggle a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    toggle: function toggle(context, id) {
        var chat = context.state.info[id];
        if (chat && chat.open) {
            context.commit('toggle', id);
            context.commit('storeState');
        }
    },

    /**
     * Leave a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {number} id
     */
    leave: function leave(context, id) {
        // Optimistic update.
        context.commit('delete', id);
        joms.ajax({ func: 'chat,ajaxLeaveChat', data: [id] });
    },

    /**
     * Add users to the conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {number[]} payload.users
     */
    addUsers: function addUsers(context, payload) {
        var chatid = payload.chatid,
            userids = payload.userids;

        userids = _.map(userids, String);
        userids = JSON.stringify(userids);

        context.commit('addUsers', payload);
        // joms.ajax({
        //     func: 'chat,ajaxAddPeople',
        //     data: [ chatid, userids ],
        //     callback: function() {
        //         context.commit('addUsers', payload);
        //     }
        // });    
    },

    /**
     * Mute conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     */
    mute: function mute(context, payload) {
        var id = payload.id;

        context.commit('mute', id);
        joms.ajax({ func: 'chat,ajaxMuteChat', data: [id, 1] });
    },

    /**
     * Unmute conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     */
    unmute: function unmute(context, payload) {
        var id = payload.id;

        context.commit('unmute', id);
        joms.ajax({ func: 'chat,ajaxMuteChat', data: [id, 0] });
    },

    seen: function seen(context, id) {
        return jQuery.Deferred(function (defer) {
            joms.ajax({
                func: 'chat,ajaxSeen',
                data: [id],
                callback: function callback() {
                    context.commit('seen', id);
                    defer.resolve();
                }
            });
        });
    },

    seenBy: function seenBy(context, payload) {
        if (payload.userid != window.joms_my_id) {
            context.commit('seenBy', payload);
        }
    },

    clearSeen: function clearSeen(context, payload) {
        context.commit('clearSeen', payload);
    },

    unread: function unread(context, id) {
        context.commit('unread', id);
    },

    syncState: function syncState(context) {
        context.commit('syncState');
    },

    setTopSidebar: function setTopSidebar(context, id) {
        context.commit('setTopSidebar', id);
    },

    addSidebarItem: function addSidebarItem(context, id) {
        context.commit('addSidebarItem', id);
    },

    setActiveWindow: function setActiveWindow(context, id) {
        context.commit('setActiveWindow', id);
    },

    setLimitOpened: function setLimitOpened(context) {
        var body_width = document.body.clientWidth,
            sidebar_width = 220,
            window_width = 240,
            left_space = 20,
            limit = 0;

        limit = parseInt((body_width - sidebar_width - left_space - 60) / 240);
        context.commit('setLimitOpened', limit);
    }

};

},{}],8:[function(require,module,exports){
(function (global){
'use strict';

var localStorage = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage;

module.exports = {

    opened: function opened(state, getters) {
        var opened = [],
            needClose = [],
            limit = state.limitOpened,
            active = state.active,
            idx;

        if (limit) {
            var chats = _.filter(state.opened, function (id) {
                return state.info[id];
            });

            if (chats.length > limit && limit) {
                _.each(chats.splice(limit), function (id) {
                    if (id != active) {
                        needClose.push(id);
                    }
                });

                idx = chats.indexOf(active);
                if (active && idx === -1) {
                    needClose.push(chats.pop());
                    chats.push(active);
                }
            }

            _.each(chats, function (id) {
                if (state.info[id]) {
                    opened.push(state.info[id]);
                }
            });
        } else {
            needClose = state.opened;
        }

        return {
            opened: opened,
            needClose: needClose
        };
    },

    sidebar: function sidebar(state, getters) {
        var sidebar = [];
        _.each(state.sidebar, function (id) {
            if (state.info[id]) {
                sidebar.push(state.info[id]);
            }
        });

        return sidebar;
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
'use strict';

module.exports = {
    namespaced: true,
    state: require('./state'),
    getters: require('./getters'),
    mutations: require('./mutations'),
    actions: require('./actions'),
    modules: {
        messages: require('./messages')
    }
};

},{"./actions":7,"./getters":8,"./messages":12,"./mutations":15,"./state":16}],10:[function(require,module,exports){
'use strict';

module.exports = {

    /**
     * Fetch messages for a conversion.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @return {jQuery.Deferred}
     */
    fetch: function fetch(context, payload) {
        return jQuery.Deferred(function (defer) {
            var chatid = payload.id,
                offset = payload.oldestMsg,
                seen = 0,
                params = [chatid, offset, seen];

            joms.ajax({
                func: 'chat,ajaxGetLastChat',
                data: params,
                callback: function callback(json) {
                    var messages = [];
                    if (_.isArray(json.messages) && json.messages.length) {
                        _.each(json.messages, function (message) {
                            messages.push(message);
                        });
                    }

                    if (_.isArray(json.seen) && json.seen.length) {
                        _.each(json.seen, function (item) {
                            messages.push(item);
                        });
                    }

                    messages.sort(function (a, b) {
                        return +b.id - +a.id;
                    });

                    if (messages.length) {
                        context.commit('append', { messages: messages });
                    }

                    // Let caller know that the action is complete.
                    defer.resolve({ messages: messages, seen: json.seen });
                }
            });
        });
    },

    /**
     * Submit message for a conversation.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.data
     * @return {jQuery.Deferred}
     */
    submit: function submit(context, payload) {
        return jQuery.Deferred(function (defer) {
            var chatId = payload.id,
                data = payload.data,
                attachment = data.attachment || {},
                timestamp = new Date().getTime(),
                messageId = 'temp_' + timestamp;

            // Assign temporary id to the message.
            data = _.extend({}, data, { id: messageId });

            // Add temporary message.
            context.commit('prepend', { messages: [data] });

            // Sanitize attachment parameter
            if (attachment.type && attachment.id) {
                attachment = { type: attachment.type, id: attachment.id };
            } else {
                attachment = {};
            }

            // Submit actual message.
            joms.ajax({
                func: 'chat,ajaxAddChat',
                data: [chatId, data.content, JSON.stringify(attachment)],
                callback: function callback(json) {
                    if (json.reply_id) {
                        var item = {
                            tempid: messageId,
                            id: json.reply_id,
                            chatid: json.chat_id
                        };
                        context.commit('updateTemp', item);
                        defer.resolve();
                    } else {
                        defer.reject();
                    }
                }
            });
        });
    },

    /**
     * Check new messages for a conversion.
     * @param {Object} context
     * @param {Function} context.commit
     * @param {Object} context.state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.lastMessageId
     * @return {jQuery.Deferred}
     */
    check: function check(context, payload) {
        return jQuery.Deferred(function (defer) {
            var ids = payload.ids,
                xhr;

            // Sanity check.
            if (!(_.isArray(ids) && ids.length)) {
                defer.resolve();
                return;
            }

            // Get latest messages for each conversations.
            ids = _.map(ids, function (id) {
                var messages = context.getters['sortedMessages'](id),
                    last;

                if (messages && messages.length) {
                    messages = _.filter(messages, function (item) {
                        return +item.id;
                    });
                    last = messages[messages.length - 1];
                    if (last && +last.id) {
                        last = +last.id;
                    }
                }

                return [+id, last || 0];
            });

            xhr = joms.ajax({
                func: 'chat,ajaxGetLatestActivities',
                data: [JSON.stringify(ids)],
                callback: function callback(json) {
                    if (json) {
                        _.each(json, function (messages, chatId) {
                            _.each(messages, function (item) {
                                if (typeof item.attachment === 'string') {
                                    item.attachment = JSON.parse(item.attachment);
                                };

                                context.commit('add', {
                                    id: chatId,
                                    message: item
                                });
                            });
                        });
                    }

                    defer.resolve();
                }
            });
        });
    }

};

},{}],11:[function(require,module,exports){
"use strict";

module.exports = {
    /**
     * Group oldest message ID of a conversation.
     * @param {Object} state
     * @param {Object} getters
     */
    newestMessageID: function newestMessageID(state, getters) {
        return function (chatId) {
            var keys, key;

            if (state[chatId]) {
                keys = _.chain(state[chatId]).keys().filter(function (messageId) {
                    return +messageId;
                }).sortBy(function (messageId) {
                    return +messageId;
                }).value();

                if (keys.length) {
                    key = keys[keys.length - 1];
                }
            }

            return key;
        };
    }

};

},{}],12:[function(require,module,exports){
'use strict';

module.exports = {
    namespaced: true,
    state: require('./state'),
    getters: require('./getters'),
    mutations: require('./mutations'),
    actions: require('./actions')
};

},{"./actions":10,"./getters":11,"./mutations":13,"./state":14}],13:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue;

module.exports = {

    add: function add(state, payload) {
        _.each(payload.data, function (message) {
            var existed = state.filter(function (item) {
                return +item.id === +message.id;
            });

            if (existed.length === 0) {
                state.unshift(message);
            }
        });
    },

    append: function append(state, payload) {
        _.each(payload.messages, function (message) {
            var existed = state.filter(function (item) {
                return +item.id === +message.id;
            });

            if (existed.length === 0) {
                state.unshift(message);
            }
        });
    },
    prepend: function prepend(state, payload) {
        _.each(payload.messages, function (message) {
            var existed = state.filter(function (item) {
                return +item.id === +message.id;
            });

            if (existed.length === 0) {
                state.push(message);
            }
        });
    },

    updateTemp: function updateTemp(state, payload) {

        var temp = state.filter(function (item) {
            return payload.tempid === item.id;
        });

        if (temp.length) {
            _.each(temp, function (msg) {
                Vue.set(msg, 'id', payload.id);
            });
        }
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
"use strict";

module.exports = [];

},{}],15:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue,
    localStorage = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).storage,
    CHATSTATE_MAXIMIZED = 1,
    CHATSTATE_MINIMIZED = 2,
    CHATSTATE_CLOSED = 0;

module.exports = {

    /**
     * Add a new chat.
     * @param {State} state
     * @param {Object} chat
     */
    add: function add(state, chat) {
        if (state.info[chat.id]) {
            _.extend(chat, state.info[chat.id]);
        }
        Vue.set(state.info, chat.id, chat);
    },

    addSidebarItem: function addSidebarItem(state, id) {
        if (state.sidebar.indexOf(+id) === -1) {
            state.sidebar.push(+id);
        }
    },

    addUsers: function addUsers(state, payload) {
        var chatid = payload.chatid,
            userids = payload.userids,
            chat = state.info[chatid];

        if (chat) {
            userids.forEach(function (id) {
                if (chat.users.indexOf(+id) < 0) {
                    Vue.set(chat, 'participants', +chat.participants + 1);
                    chat.users.push(+id);
                }
            });
        }
    },

    initialized: function initialized(state, payload) {
        var chat = state.info[payload.id];
        if (chat) {
            Vue.set(chat, 'initialized', true);
        }
    },

    /**
     * Update an existing chat.
     * @param {State} state
     * @param {Object} payload
     */
    update: function update(state, payload) {
        var id = payload.id,
            chat = payload.chat,
            prevChat = state.info[id];

        chat = _.extend({}, prevChat || {}, chat);
        Vue.set(state.info, id, chat);
    },

    /**
     * Remove an existing chat.
     * @param {State} state
     * @param {number} id
     */
    delete: function _delete(state, id) {
        var info = void 0;

        _.each(state.info, function (item) {
            if (item.id == id) {
                info = item;
            }
        });

        if (info) {
            Vue.delete(state.info, id);
        }
    },

    /**
     * Open a chat.
     * @param {State} state
     * @param {number} id
     */
    open: function open(state, id) {
        var info = state.info[id],
            idx = state.opened.indexOf(+id);

        if (idx === -1) {
            state.opened.push(+id);
        }

        if (info && info.open !== 1) {
            Vue.set(state.info[id], 'open', CHATSTATE_MAXIMIZED);
        }
    },

    /**
     * Close a chat.
     * @param {State} state
     * @param {number} id
     */
    close: function close(state, id) {
        var info = void 0,
            chatbarState = void 0,
            chatState = void 0,
            idx = state.opened.indexOf(+id);

        if (idx != -1) {
            state.opened.splice(idx, 1);
        }

        if (state.info[id]) {
            info = state.info[id];

            Vue.set(info, 'open', CHATSTATE_CLOSED);
        }
    },

    /**
     * Toggle a chat.
     * @param {State} state
     * @param {number} id
     */
    toggle: function toggle(state, id) {
        var info = state.info[id],
            chatbarState = void 0,
            chatState = void 0,
            openedState = void 0;

        if (info) {
            openedState = info.open === CHATSTATE_MINIMIZED ? CHATSTATE_MAXIMIZED : CHATSTATE_MINIMIZED;
            Vue.set(state.info[id], 'open', openedState);
        }
    },

    /**
     * Mute a chat.
     * @param {State} state
     * @param {number} id
     */
    mute: function mute(state, id) {
        var info = void 0;

        _.each(state.info, function (item) {
            if (item.id == id) {
                info = item;
            }
        });

        if (info) {
            Vue.set(info, 'mute', 1);
        }
    },

    /**
     * Unmute a chat.
     * @param {State} state
     * @param {number} id
     */
    unmute: function unmute(state, id) {
        var info = void 0;

        _.each(state.info, function (item) {
            if (item.id == id) {
                info = item;
            }
        });

        if (info) {
            Vue.set(info, 'mute', 0);
        }
    },

    seen: function seen(state, id) {
        var chat = state.info[id];
        if (chat) {
            Vue.set(chat, 'seen', 1);
        }
    },

    seenBy: function seenBy(state, payload) {
        var userid = payload.userid,
            chatid = payload.chatid,
            chat = state.info[chatid];
        if (!chat) {
            return;
        }

        if (!chat.seenBy) {
            Vue.set(chat, 'seenBy', []);
        }

        chat.seenBy.push(userid);
    },

    clearSeen: function clearSeen(state, payload) {
        var chatid = payload.chatid,
            chat = state.info[chatid];
        if (!chat) {
            return;
        }

        if (chat.seenBy) {
            chat.seenBy.splice(0, chat.seenBy.length);
        }
    },

    unread: function unread(state, id) {
        var chat = state.info[id];
        Vue.set(chat, 'seen', 0);
    },

    storeState: function storeState(state) {
        var chatbarState = localStorage.get('chatbar') || {},
            info = chatbarState.info || {};

        _.each(state.info, function (item) {
            if (typeof item.open !== 'undefined') {
                info[item.id] = {};
                info[item.id].open = item.open;
            }
        });

        chatbarState.info = info;
        chatbarState.opened = state.opened;
        localStorage.set('chatbar', chatbarState);
    },

    syncState: function syncState(state) {
        var chatbarState = localStorage.get('chatbar') || {},
            info = chatbarState.info || {},
            opened = chatbarState.opened || [];

        _.each(info, function (item, key) {
            if (state.info[key]) {
                Vue.set(state.info[key], 'open', item.open);
            }
        });

        _.each(opened, function (id) {
            if (state.opened.indexOf(+id) === -1) {
                state.opened.push(id);
            }
        });
    },

    setTopSidebar: function setTopSidebar(state, id) {
        var idx = state.sidebar.indexOf(+id);
        if (idx !== -1) {
            state.sidebar.splice(idx, 1);
            state.sidebar.unshift(+id);
        } else if (state.info[id]) {
            state.sidebar.unshift(+id);
        }
    },

    setActiveWindow: function setActiveWindow(state, id) {
        var chat = state.info[id];
        if (chat && chat.open === CHATSTATE_MAXIMIZED) {
            Vue.set(state, 'active', +id);
        } else {
            Vue.set(state, 'active', 0);
        }
    },

    setLimitOpened: function setLimitOpened(state, limit) {
        Vue.set(state, 'limitOpened', +limit);
    }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],16:[function(require,module,exports){
"use strict";

module.exports = {
    info: {},
    sidebar: [],
    opened: [],
    active: 0,
    limitOpened: 0
};

},{}],17:[function(require,module,exports){
(function (global){
'use strict';

var Vuex = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vuex;

module.exports = new Vuex.Store({
    modules: {
        users: require('./users'),
        chats: require('./chats')
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chats":9,"./users":20}],18:[function(require,module,exports){
"use strict";

module.exports = {};

},{}],19:[function(require,module,exports){
'use strict';

module.exports = {

    /**
     * Get name of particular user.
     * @param {Object} state
     * @param {Object} getters
     */
    name: function name(state, getters) {
        return function (userId) {
            var name;

            if (state[userId]) {
                name = state[userId].name;
            }

            return name;
        };
    },

    /**
     * Get avatar image of particular user.
     * @param {Object} state
     * @param {Object} getters
     */
    avatar: function avatar(state, getters) {
        return function (userId) {
            var avatar;

            if (state[userId]) {
                avatar = state[userId].avatar;
            }

            return avatar;
        };
    },

    /**
     * Search users by keyword.
     * @param {Object} state
     * @param {Object} getters
     */
    search: function search(state, getters) {
        return function (keyword) {
            keyword = (keyword || '').trim().toLowerCase();
            return _.filter(state, function (user) {
                return keyword && (user.name || '').toLowerCase().indexOf(keyword) !== -1;
            });
        };
    }

};

},{}],20:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./actions":18,"./getters":19,"./mutations":21,"./state":22,"dup":12}],21:[function(require,module,exports){
(function (global){
'use strict';

var Vue = (typeof window !== "undefined" ? window['joms'] : typeof global !== "undefined" ? global['joms'] : null).Vue;

module.exports = {

    /**
     * Add a new user.
     * @param {State} state
     * @param {Object} payload
     * @param {Object} payload.data
     */
    add: function add(state, payload) {
        var userData = payload.data,
            userId = userData.id;

        Vue.set(state, userId, userData);
    },

    /**
     * Edit a user.
     * @param {State} state
     * @param {Object} payload
     * @param {number} payload.id
     * @param {Object} payload.data
     */
    edit: function edit(state, payload) {
        var userId = payload.id,
            userData = payload.data,
            prevData = state[userId];

        if (prevData) {
            userData = _.extend({}, prevData, userData);
            Vue.set(state, userId, userData);
        }
    },

    /**
     * Delete a user.
     * @param {State} state
     * @param {Object} payload
     * @param {number} payload.id
     */
    delete: function _delete(state, payload) {
        var userId = payload.id,
            messageId = payload.messageId;

        if (state[userId]) {
            delete state[userId];
        }
    }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
"use strict";

module.exports = {};

},{}]},{},[1]);
